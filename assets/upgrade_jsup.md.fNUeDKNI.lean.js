import{d as i,c as a,J as s,V as l,o as n,al as t}from"./chunks/framework.eh9rp3qH.js";import{_ as e}from"./chunks/header.vue_vue_type_script_setup_true_lang.dWYU8gfP.js";import"./chunks/firstNotUndefined.BvnkRdw1.js";const h=l('<h2 id="一-闭包" tabindex="-1">一，闭包 <a class="header-anchor" href="#一-闭包" aria-label="Permalink to &quot;一，闭包&quot;">​</a></h2><p><strong>内部函数访问其所在的外部函数中声明的参数和变量,形成的词法环境叫闭包</strong></p><ol><li><p>闭包有三个特性：</p><ul><li>函数嵌套函数</li><li>函数内部访问外部函数的参数或变量</li><li>可以使函数中的变量可以长期驻扎在内存（延长了变量的生命周期）</li></ul></li><li><p>使用闭包的好处：</p><ul><li>变量长期驻扎在内存中</li><li>避免全局变量的污染（多人定义同样名字的全部变量冲突）</li><li>私有成员的存在</li></ul></li><li><p>使用闭包的坏处：</p><ul><li>常驻内存</li><li>会增大内存的使用量</li><li>使用不当会造成内存泄露</li></ul></li></ol><h2 id="二-原型和原型链" tabindex="-1">二，原型和原型链 <a class="header-anchor" href="#二-原型和原型链" aria-label="Permalink to &quot;二，原型和原型链&quot;">​</a></h2><h3 id="_1-原型" tabindex="-1">1，原型 <a class="header-anchor" href="#_1-原型" aria-label="Permalink to &quot;1，原型&quot;">​</a></h3><p>每一个构造函数，都会有一个 prototype 属性。该属性指向一个对象，该对象称之为 原型对象,即原型。</p><h3 id="_2-原型链" tabindex="-1">2，原型链 <a class="header-anchor" href="#_2-原型链" aria-label="Permalink to &quot;2，原型链&quot;">​</a></h3><p>当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的<strong>proto</strong>上查找，即它的构造函数的 prototype，如果还没有找到就会再在构造函数的 prototype 的<strong>proto</strong>中查找(即上一层构造函数的 prototype)，这样一层一层向上查找直到 Object 的 prototype 结束,这样就会形成一个链式结构，我们称为原型链。我们可以说：它们是继承关系</p><p><img src="'+t+`" alt="图解"></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>顶层 Object 的原型是 null</strong></p></div><h2 id="三-作用域和作用域链" tabindex="-1">三，作用域和作用域链 <a class="header-anchor" href="#三-作用域和作用域链" aria-label="Permalink to &quot;三，作用域和作用域链&quot;">​</a></h2><h3 id="_1-作用域" tabindex="-1">1，作用域 <a class="header-anchor" href="#_1-作用域" aria-label="Permalink to &quot;1，作用域&quot;">​</a></h3><p>作用域是指程序源代码中定义变量的区域，简单来说，一段程序代码中所用到的变量并不总是有效的，而限定这个变量的可用性的代码范围就是这个变量的作用域。</p><p>js 的三种作用域：</p><ol><li>全局作用域 全局作用域是最外围的一个作用域。根据 ECMAScript 实现所在的宿主环境不同，表示全局作用域的对象也不一样。在浏览器中，全局作用域就是 window 对象，node 则是 global 对象。</li><li>局部作用域 和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的是函数内部。</li><li>块级作用域 ES5 本身是没有块级作用域，ES6 引入了块级作用域，让变量的生命周期更加可控，使用 let 和 const 声明的变量在指定块（简单理解就是一对花括号）的作用域外无法被访问。</li></ol><h3 id="_2-作用域链" tabindex="-1">2，作用域链 <a class="header-anchor" href="#_2-作用域链" aria-label="Permalink to &quot;2，作用域链&quot;">​</a></h3><p>一般情况下，变量取值到创建这个变量的函数的作用域中取值。但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</p><h2 id="四-继承" tabindex="-1">四，继承 <a class="header-anchor" href="#四-继承" aria-label="Permalink to &quot;四，继承&quot;">​</a></h2><p>它允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。通过继承，子类可以重用父类的代码，并且可以在不修改父类的情况下添加新的功能或修改已有的功能。</p><ol><li>构造函数继承（在子类的构造函数中执行父类的构造函数，并为其绑定子类的 this，让父类的构造函数把成员属性和方法都挂到子类的 this 上） 缺点：无法访问原型上的方法</li><li>原型链继承（将子构造函数的原型对象指向父构造函数的实例,让 constructor 重新指向子构造函数） 缺点：无法为不同的实例初始化继承来的属性</li><li>组合式继承(将原型链继承和构造函数继承组合到一起, 综合了原型链继承和构造函数继承的优点) 缺点：调用了两次父类构造函数</li><li>原型式继承（Object.create():这个方法接收两个参数：一是用作新对象原型的对象、二是为新对象定义额外属性的对象（可选参数）,核心思想：使用一个中间函数，连接父类与子类的关系。借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。）</li><li>extends 继承(class 和 extends 是 es6 新增的，class 创建一个类，extends 实现继承)</li></ol><h2 id="五-构造函数-和-class-的区别" tabindex="-1">五，构造函数 和 class 的区别 <a class="header-anchor" href="#五-构造函数-和-class-的区别" aria-label="Permalink to &quot;五，构造函数 和 class 的区别&quot;">​</a></h2><h4 id="构造函数" tabindex="-1">构造函数: <a class="header-anchor" href="#构造函数" aria-label="Permalink to &quot;构造函数:&quot;">​</a></h4><ol><li>在 JavaScript 中，用 new 关键字来调用的函数，称为构造函数。构造函数首字母一般大写</li><li>功能类似对象模板，一个构造函数可以生成任意多个实例，实例对象具有相同的属性、行为特征，但不相等。</li><li>函数体内使用 this，引用将要生成的实例对象。</li><li>必需使用 new 命令调用函数，生成实例对象。</li></ol><h4 id="class-类" tabindex="-1">class 类: <a class="header-anchor" href="#class-类" aria-label="Permalink to &quot;class 类:&quot;">​</a></h4><ol><li>类不存在变量提升（hoist），</li><li>类的方法内部如果含有 this，它默认指向类的实例，</li><li>类使用 extends 来继承，</li><li>类的数据类型就是函数，类本身就指向构造函数；使用的时候，也是直接对类使用 new 命令，跟构造函数的用法完全一致；</li></ol><h2 id="六-数组循环操作方法" tabindex="-1">六，数组循环操作方法 <a class="header-anchor" href="#六-数组循环操作方法" aria-label="Permalink to &quot;六，数组循环操作方法&quot;">​</a></h2><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}):</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//遍历数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}):</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//对数组遍历并操作数组元素,返回操作后元素组成的新数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({}));</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//对数组元素进行过滤,返回符合元素组成的新数组</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}):</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//查找数组中符合的元素</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}):</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//对数组的元素进行判断是否有符合的元素</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">every</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}):</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//对数组的元素进行判断是否全部符合</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">find</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){})</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//方法返回符合查找条件的第一个数组元素的值。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reduce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">total</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){},initialValue)：</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="七-浅拷贝和深拷贝" tabindex="-1">七，浅拷贝和深拷贝 <a class="header-anchor" href="#七-浅拷贝和深拷贝" aria-label="Permalink to &quot;七，浅拷贝和深拷贝&quot;">​</a></h2><h4 id="浅拷贝" tabindex="-1">浅拷贝 <a class="header-anchor" href="#浅拷贝" aria-label="Permalink to &quot;浅拷贝&quot;">​</a></h4><p>只复制指向某个对象的指针而不复制对象本身，新旧对象还是共享同一块内存。Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p><h4 id="深拷贝" tabindex="-1">深拷贝: <a class="header-anchor" href="#深拷贝" aria-label="Permalink to &quot;深拷贝:&quot;">​</a></h4><p>会另外创建一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 JSON.parse(JSON.stringify()) 原理： 用 JSON.stringify 将对象转成 JSON 字符串，再用 JSON.parse()把字符串解析成对象，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</p><div class="tip custom-block"><p class="custom-block-title">手写</p><p><a href="./../handlewrite/">深拷贝</a></p></div><h2 id="八-赋值-地址传递-和浅拷贝" tabindex="-1">八，赋值(地址传递)和浅拷贝 <a class="header-anchor" href="#八-赋值-地址传递-和浅拷贝" aria-label="Permalink to &quot;八，赋值(地址传递)和浅拷贝&quot;">​</a></h2><ul><li>当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li><li>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即：<span style="color:red;"> 默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</span></li></ul><h2 id="九-栈内存和堆内存" tabindex="-1">九，栈内存和堆内存 <a class="header-anchor" href="#九-栈内存和堆内存" aria-label="Permalink to &quot;九，栈内存和堆内存&quot;">​</a></h2><ol><li>栈（stack）：由编译器自动分配释放，存放函数的参数值，局部变量等；</li><li>堆（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统释放。</li><li>栈是先进后出，队列是先进先出。</li></ol><h2 id="十-for-in-和-for-of-和-foreach" tabindex="-1">十，for..in 和 for..of 和 forEach <a class="header-anchor" href="#十-for-in-和-for-of-和-foreach" aria-label="Permalink to &quot;十，for..in 和 for..of 和 forEach&quot;">​</a></h2><p><strong>for ..in</strong></p><ul><li>可以循环数组也能循环对象，循环遍历的值是数据结构的键值；</li><li>可以使用 return、break、continue 中断循环；</li><li>在有些情况下会以随机顺序遍历数组，所以最好用来遍历对象；</li></ul><p><strong>for ..of</strong></p><ul><li>可以循环可迭代对象（如数组、字符串等），循环遍历的值是数据结构的值；</li><li>可以使用 return、break、continue 中断循环；</li></ul><p><strong>forEach</strong></p><ul><li>在回调函数内部有三个参数：item、index、arr 分别表示当前项、当前项的索引下标、数组本身；</li><li>会对数组的每一个元素执行一次提供的函数，不改变原数组、没有返回值（undefined）；</li></ul><h2 id="十一-foreach-和-map-方法的区别" tabindex="-1">十一，forEach 和 map 方法的区别 <a class="header-anchor" href="#十一-foreach-和-map-方法的区别" aria-label="Permalink to &quot;十一，forEach 和 map 方法的区别&quot;">​</a></h2><p><strong>相同点</strong></p><ol><li>都是循环遍历数组的方法</li><li>forEach 和 map 方法里每次执行匿名函数都支持 3 个参数，参数分别是 value（当前每一项）、index（索引值）、array（原数组）</li><li>匿名函数中的 this 都是指向 window</li><li>只能遍历数组</li></ol><p><strong>区别</strong></p><ol><li>forEach()返回值是 undefined，</li><li>map()返回一个新数组</li></ol>`,49),u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"upgrade/jsup.md","filePath":"upgrade/jsup.md","lastUpdated":1707040875000}'),r={name:"upgrade/jsup.md"},g=i({...r,setup(p){return(o,k)=>(n(),a("div",null,[s(e),h]))}});export{u as __pageData,g as default};
